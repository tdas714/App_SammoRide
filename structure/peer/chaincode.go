package peer

import "github.com/App-SammoRide/structure"

type ChaincodeSpec_Type int32

const (
	ChaincodeSpec_UNDEFINED ChaincodeSpec_Type = 0
	ChaincodeSpec_GOLANG    ChaincodeSpec_Type = 1
)

var ChaincodeSpec_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "GOLANG",
}

var ChaincodeSpec_Type_value = map[string]int32{
	"UNDEFINED": 0,
	"GOLANG":    1,
}

//ChaincodeID contains the path as specified by the deploy transaction
//that created it as well as the hashCode that is generated by the
//system for the path. From the user level (ie, CLI, REST API and so on)
//deploy transaction is expected to provide the path and other requests
//are expected to provide the hashCode. The other value will be ignored.
//Internally, the structure could contain both values. For instance, the
//hashCode will be set when first generated using the path
type ChaincodeID struct {
	//deploy transaction will use the path
	Path string
	//all other requests will use the name (really a hashcode) generated by
	//the deploy transaction
	Name string
	//user friendly version name for the chaincode
	Version string
}

func (m *ChaincodeID) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ChaincodeID) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChaincodeID) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Carries the chaincode function and its arguments.
// UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
// the []byte-based current ChaincodeInput structure.
type ChaincodeInput struct {
	Args        [][]byte
	Decorations map[string][]byte
	// is_init is used for the application to signal that an invocation is to be routed
	// to the legacy 'Init' function for compatibility with chaincodes which handled
	// Init in the old way.  New applications should manage their initialized state
	// themselves.
	IsInit bool
}

func (m *ChaincodeInput) GetArgs() [][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ChaincodeInput) GetDecorations() map[string][]byte {
	if m != nil {
		return m.Decorations
	}
	return nil
}

func (m *ChaincodeInput) GetIsInit() bool {
	if m != nil {
		return m.IsInit
	}
	return false
}

// Carries the chaincode specification. This is the actual metadata required for
// defining a chaincode.
type ChaincodeSpec struct {
	Type        ChaincodeSpec_Type
	ChaincodeId *ChaincodeID
	Input       *ChaincodeInput
	Timeout     int32
}

func (m *ChaincodeSpec) GetType() ChaincodeSpec_Type {
	if m != nil {
		return m.Type
	}
	return ChaincodeSpec_UNDEFINED
}

func (m *ChaincodeSpec) GetChaincodeId() *ChaincodeID {
	if m != nil {
		return m.ChaincodeId
	}
	return nil
}

func (m *ChaincodeSpec) GetInput() *ChaincodeInput {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ChaincodeSpec) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// Specify the deployment of a chaincode.
// TODO: Define `codePackage`.
type ChaincodeDeploymentSpec struct {
	ChaincodeSpec *ChaincodeSpec
	CodePackage   []byte
}

func (m *ChaincodeDeploymentSpec) GetChaincodeSpec() *ChaincodeSpec {
	if m != nil {
		return m.ChaincodeSpec
	}
	return nil
}

func (m *ChaincodeDeploymentSpec) GetCodePackage() []byte {
	if m != nil {
		return m.CodePackage
	}
	return nil
}

// Carries the chaincode function and its arguments.
type ChaincodeInvocationSpec struct {
	ChaincodeSpec *ChaincodeSpec
}

func (m *ChaincodeInvocationSpec) GetChaincodeSpec() *ChaincodeSpec {
	if m != nil {
		return m.ChaincodeSpec
	}
	return nil
}

// LifecycleEvent is used as the payload of the chaincode event emitted by LSCC
type LifecycleEvent struct {
	ChaincodeName string
}

func (m *LifecycleEvent) GetChaincodeName() string {
	if m != nil {
		return m.ChaincodeName
	}
	return ""
}

// CDSData is data stored in the LSCC on instantiation of a CC
// for CDSPackage.  This needs to be serialized for ChaincodeData
// hence the protobuf format
type CDSData struct {
	Hash         []byte
	Metadatahash []byte
}

func (m *CDSData) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *CDSData) GetMetadatahash() []byte {
	if m != nil {
		return m.Metadatahash
	}
	return nil
}

// ChaincodeData defines the datastructure for chaincodes to be serialized by proto
// Type provides an additional check by directing to use a specific package after instantiation
// Data is Type specific (see CDSPackage and SignedCDSPackage)
type ChaincodeData struct {
	// Name of the chaincode
	Name string
	// Version of the chaincode
	Version string
	// Escc for the chaincode instance
	Escc string
	// Vscc for the chaincode instance
	Vscc string
	// Policy endorsement policy for the chaincode instance
	Policy *structure.SignaturePolicyEnvelope
	// Data data specific to the package
	Data []byte
	// Id of the chaincode that's the unique fingerprint for the CC This is not
	// currently used anywhere but serves as a good eyecatcher
	Id []byte
	// InstantiationPolicy for the chaincode
	InstantiationPolicy *structure.SignaturePolicyEnvelope
}

func (m *ChaincodeData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChaincodeData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ChaincodeData) GetEscc() string {
	if m != nil {
		return m.Escc
	}
	return ""
}

func (m *ChaincodeData) GetVscc() string {
	if m != nil {
		return m.Vscc
	}
	return ""
}

func (m *ChaincodeData) GetPolicy() *structure.SignaturePolicyEnvelope {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *ChaincodeData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ChaincodeData) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ChaincodeData) GetInstantiationPolicy() *structure.SignaturePolicyEnvelope {
	if m != nil {
		return m.InstantiationPolicy
	}
	return nil
}
